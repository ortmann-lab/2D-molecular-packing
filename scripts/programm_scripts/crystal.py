import itertools, copy 

import numpy as np 
from scipy.spatial import cKDTree

import constants




class CrystalStruture:
    
    def __init__(self, a = 30, b = 30, c = 10, alpha = 90, beta = 90, gamma = 90, sites = None):
        
        """unit cell input paramaters"""

        self.a = a
        self.b = b
        self.c = c
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.sites = sites


    @property
    def lattice_matrix(self):
        
        alp = np.deg2rad(self.alpha)
        bt = np.deg2rad(self.beta)
        gm = np.deg2rad(self.gamma)
        
        multiplier = (np.cos(alp) - np.cos(gm) * np.cos(bt)) / np.sin(gm)
        
        return np.array([[self.a, 0, 0],
                         [self.b * np.cos(gm), self.b * np.sin(gm), 0], 
                         [self.c * np.cos(bt), self.c * multiplier, self.c * np.sqrt(np.sin(bt)**2 - multiplier**2)]])

    
    def write_cif(self, path):
        
        with open(f'{path}.cif','wt' ) as cif_file:
    
            cif_file.write(f'data_{path}\n')
            cif_file.write('\n')
            cif_file.write("_audit_creation_method             'generated by generator'\n")
            cif_file.write('\n')
            cif_file.write("_symmetry_space_group_name_H-M     '(unknown)'       \n")
            cif_file.write('_symmetry_Int_Tables_number        1\n')                              #POSIBLE MULTPLIT \n in one line (NEED TO CHECK)
            cif_file.write('\n')
            cif_file.write('\n')
            cif_file.write("_space_group_symop_operation_xyz   'x, y, z'\n")
            cif_file.write('\n')
            cif_file.write('_cell_length_a                        {:12.6f}\n'.format(self.a))
            cif_file.write('_cell_length_b                        {:12.6f}\n'.format(self.b))
            cif_file.write('_cell_length_c                        {:12.6f}\n'.format(self.c))
            cif_file.write('_cell_angle_alpha                        {:12.6f}\n'.format(self.alpha))
            cif_file.write('_cell_angle_beta                        {:12.6f}\n'.format(self.beta))
            cif_file.write('_cell_angle_gamma                       {:12.6f}\n'.format(self.gamma))
            cif_file.write('\n')
            cif_file.write('loop_\n')
            cif_file.write('_atom_site_label\n')
            cif_file.write('_atom_site_fract_x\n')
            cif_file.write('_atom_site_fract_y\n')
            cif_file.write('_atom_site_fract_z\n')
            cif_file.write('_atom_site_U_iso_or_equiv\n')
            cif_file.write('_atom_site_adp_type\n')
            cif_file.write('_atom_site_occupancy\n')
            cif_file.write('_atom_site_charge\n')
            
    
            for site in self.sites:
                for element, coordinates, charge in zip(site.elements, site.frac_coordinates, site.charges):
                    cif_file.write(f'  {element}          {round(coordinates[0], 7)}      {round(coordinates[1], 7)}      {round(coordinates[2], 7)}      0.00000      Uiso      1.00      {charge} \n')


    def write_gulp(self, path):
        
        number_of_atoms = sum([len(site.cart_coordinates) for site in self.sites])

        with open(f'{path}.gin','wt' ) as gulp_input:
            gulp_input.write('opti molmec rigid kcal\n')
            gulp_input.write('cutp 12.5 mdf 9.0\n')
            gulp_input.write('title\n')
            gulp_input.write(f'{path}\n')
            gulp_input.write('end\n')
            gulp_input.write('maxcyc 50\n')
            gulp_input.write('stepmx 0.1\n')
            gulp_input.write('switch rfo gnorm 0.1\n')
            gulp_input.write('fix_atom last\n')
            gulp_input.write('cell\n')
            gulp_input.write(f'{self.a} {self.b} {self.c} {self.alpha} {self.beta} {self.gamma} 1 1 0 0 0 1 \n')
            gulp_input.write(f'fractional {number_of_atoms} \n')


            for site in self.sites:
 
                gulp_input.write(f'{site.ff_atom_types[0]:4} core {site.frac_coordinates[0][0]:10.6f} {site.frac_coordinates[0][1]:10.6f} {site.frac_coordinates[0][2]:10.6f} {site.charges[0]:10.6f} 1.0 0.0 1 1 0\n')
                gulp_input.write(f'{site.ff_atom_types[1]:4} core {site.frac_coordinates[1][0]:10.6f} {site.frac_coordinates[1][1]:10.6f} {site.frac_coordinates[1][2]:10.6f} {site.charges[1]:10.6f} 1.0 0.0 0 0 1\n')
                
                for atom in range(2,len(site.frac_coordinates)):
                    gulp_input.write(f'{site.ff_atom_types[atom]:4} core {site.frac_coordinates[atom][0]:10.6f} {site.frac_coordinates[atom][1]:10.6f} {site.frac_coordinates[atom][2]:10.6f} {site.charges[atom]:10.6f} 1.0 0.0 1 1 0\n')

                
            gulp_input.write('\n')
            gulp_input.write('Species\n')
            
            for key, value in constants.gulp_dreiding.items():
                gulp_input.write(f'{key} core {value}\n')
                
            gulp_input.write('\n')
            gulp_input.write('library dreiding \n')
            gulp_input.write('\n')
            gulp_input.write(f'output cif {path}_relaxed.cif')


    def check_sites_overlap(self, site_1, site_2, overlap_threshold = 0.9):
    
        coords = [site_1.cart_coordinates, site_2.cart_coordinates]
        vdw_radii = [site_1.get_vdw_radii(), site_2.get_vdw_radii()]

        if len(coords[0]) >= len(coords[1]):
            tree_idx = 0
            set_idx = 1
        else:
            tree_idx = 1
            set_idx = 0

        tree_coords = cKDTree(coords[tree_idx])
        distances, indices = tree_coords.query(coords[set_idx])

        for i, j in enumerate(indices):
            if (vdw_radii[set_idx][i] + vdw_radii[tree_idx][j])*overlap_threshold > distances[i]:
                return True     
            else:
                continue

        return False


    def single_cell_overlap(self):   # False if NOT overlap !!!

        pairs = list(itertools.combinations(range(len(self.sites)), 2))
        
        for i, j in pairs:
            if self.check_sites_overlap(self.sites[i], self.sites[j]) == True:
                return True
            else:
                continue
                
        return False


    def super_cell_overlap(self, supercell = np.array([[-1, -1], [-1, 0], [-1, 1], [ 0, -1], [ 0, 1], [ 1, -1], [ 1, 0], [ 1, 1]]) ):   # False if NOT overlap !!!

        pairs = list(itertools.product(range(len(self.sites)), repeat = 2))

        for cell in range(len(supercell)):
        
            for i, j in pairs:
                
                copy_j_site = copy.deepcopy(self.sites[j])
                copy_j_site.translate_site(np.array([supercell[cell][0], supercell[cell][1], 0]))

                if self.check_sites_overlap(self.sites[i], copy_j_site) == True:
                    self.sites[j].translate_site(-np.array([supercell[cell][0], supercell[cell][1], 0]))
                    return True
                else:
                    self.sites[j].translate_site(-np.array([supercell[cell][0], supercell[cell][1], 0]))
                
        return False









